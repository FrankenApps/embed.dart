<br/>

<div align="center">
<img src="https://github.com/fujidaiti/embed.dart/assets/68946713/8efa648b-c216-4f16-a922-7e9f1fdfb32b" width="600"/>
<br />
<br />
<h2 align="center">embed.dart</h2>
  <p align="center">
  	Code generation for embedding arbitary file content in Dart code
    <br />
    <br />
    <a href="https://pub.dev/documentation/primer_progress_bar/latest/"><strong>Explore the docs »</strong></a>
    <br />
    <br />
    <a href="https://pub.dev/packages/embed">Pub.dev</a>
    ·
    <a href="https://github.com/fujidaiti/primer_progress_bar/issues?q=is%3Aopen+label%3Abug+sort%3Aupdated-desc">Report Bug</a>
    ·
    <a href="https://github.com/fujidaiti/primer_progress_bar/issues?q=is%3Aopen+label%3Aenhancement+sort%3Aupdated-desc">Request Feature</a>
  </p>
</div>
<br/>

<br/>


## Motivation

Occasionally, there are situations where we want to read non-dart files for some reason such as reading configuration values, or reading a test HTTP response for unit testing. A common way to do this is to load the file using [File](https://api.flutter.dev/flutter/dart-io/File-class.html) at runtime. However, since such files are usually bundled in the package, it would be nice if their contents could be read directly from within the dart codes without worring about runtime errors and async I/O processing.

There are several ways to embed structured data in dart code. We can use [multi-line string literal](https://dart.dev/language/built-in-types#strings) to embed a long text content, or [Map literal](https://dart.dev/language/collections#maps) to embed a structured data, or futher more, we can use the [records](https://dart.dev/language/records) to create a static structured data tree in type safe manner. However, there are still situations where reading non-dart file is required, since the file is downloaded from internet, or automatically generated by a script, or shared with other package written in another programming language, etc. This is where the *embed* comes in. The package tackles to this problem using code generation, enabling to directly embed contents of non-dart files in source file.

Some of the other languages have a simillar functionality to this package, such as [include_str macro](https://doc.rust-lang.org/std/macro.include_str.html) from Rust, and [embed package](https://pkg.go.dev/embed) from Go. Besides, C language also has a simillar feature: the [#include delective](https://learn.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp?view=msvc-170). What does actually the `#include "header.h"` means is it tells the C preprocessor that "please replace me with the entire content of `header.h`", and interestingly, the `#include` deletive can literaly include arbitary file other than `*.h` files. In fact, the following code works fine (might not a intended usage, but actually works fine):

```c
// text.txt
"Hello world\n"
----------------------------------------------------------------------
// main.c
#include <stdio.h>
int main(void) {
    const message =
    #include "text.txt"
    ; // ^^^^^^^^^^^^^ This line will be replaced with "Hello world\n"
    printf(message); // Displays "Hello world"
}
```

## Index

- [Motivation](#motivation)
- [Index](#index)
- [Installation](#installation)
- [Quickstart](#quickstart)
- [How to use](#how-to-use)
  - [Embed a text content as a string literal](#embed-a-text-content-as-a-string-literal)
  - [Embed a structured data as a Dart object](#embed-a-structured-data-as-a-dart-object)
    - [How is the data type determined?](#how-is-the-data-type-determined)
    - [How to restrict the structure of data to be embedded?](#how-to-restrict-the-structure-of-data-to-be-embedded)
- [Troubleshooting Guide](#troubleshooting-guide)
  - [I edited my json file to embed, but the generated code does't be updated even if reruning build\_runner](#i-edited-my-json-file-to-embed-but-the-generated-code-doest-be-updated-even-if-reruning-build_runner)
- [Roadmap](#roadmap)
- [Contributing](#contributing)
- [Thanks](#thanks)

## Installation

Run the following command:

```shell
flutter pub add embed_annotation dev:embed dev:build_runner
```

For a Dart project:

```shell
dart pub add embed_annotation dev:embed dev:build_runner
```

This command installs three packages:

- [embed](https://pub.dev/packages/embed) : the code generator
- [embed_annotation](https://pub.dev/packages/embed_annotation) : a package exposing annotations for embed
- [build_runner](https://pub.dev/packages/build_runner) : a tool to run code generators, published by the Dart team

## Quickstart

Here's an example of embedding the content of the `pubspec.yaml` in the Dart code as an object:

```dart
// This file is 'main.dart'

// Import annotations
import 'package:embed_annotation/embed_annotation.dart';

// Like other code generation packages, you need to add this line
part 'main.g.dart';

// Create an annotation specifing the location of a content file to embed
@EmbedLiteral("../pubspec.yaml")
const pubspec = _$pubspec;
```

Then, run the code generator:

```shell
dart run build_runner build
```

If your are creating a Flutter project, you can also run the generator by:

```
flutter pub build_runner build
```

Finally, you should see the  `main.g.dart` is generated in the same directory as `main.dart`.

```dart
// This is 'main.g.dart'

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'main.dart';

// **************************************************************************
// EmbedGenerator
// **************************************************************************

const _$pubspec = (
  name: "example_app",
  publishTo: "none",
  environment: (sdk: "^3.0.5"),
  dependencies: (embedAnnotation: (path: "../embed_annotation")),
  devDependencies: (
    buildRunner: "^2.4.6",
    lints: "^2.0.0",
    embed: (path: "../embed")
  ),
  dependencyOverrides: (embedAnnotation: (path: "../embed_annotation"))
);
```

You can see the content of the `pubspec.yaml` is embedded as a [record object](https://dart.dev/language/records) in the generated file. Let's print your package name to the console:

```dart
print(pubspec.name); // This should display "example_app"
```

After modifying the original file, the `pubspec.yaml` in this case, you need to run the code generator again to update the embedded content. It is recommended deleting the cache before running the `build_runner` for avoiding some code generation problem (see for the [troubleshooting guide](#troubleshooting-guide) more information), as follows:

```shell
flutter pub run build_runner clean
```



## How to use

Currently, there are 2 kinds of embedding methods:

- [Embed a text content as a String literal](#embed-a-text-content-as-a-string-literal)
- [Embed a structured data as a Dart object](#embed-a-structured-data-as-a-dart-object)

Which content to embed and how can be described by pre-defined annotations. For example, you can use the `EmbedStr` annotation to embed a text content as a string literal. Note that only top level elements are allowed to be annotated as shown below:

```dart
@EmbedStr(...) // This is OK
const topLevelVariable = ...;

class SomeClass {
  @EmbedStr(...) // This is invalid!
  static const classVariable = ...;
}
```

Each annotation requires at least one parameter, the location of the content file. There's 2 ways to specify the file location, a relative path and an absolute path. When you specify a relative path, it will be treated as relative to the parent directory of the source file in which the annotaiton is decreared. For example, say, we have a simple Flutter project that is typically structured as:

```
project_root
  |- lib
  |    |- main.dart
  |- pubspec.yaml 
```

In this scenario, we can refer the `pubspec.yaml` from the `lib/main.dart` using a relative path like `../pubspec.yaml` :

```dart
@EmbedStr("../pubspec.yaml")
const pubspec = _$pubspec;
```

Depending on the structure of your project, it may be more intuitive to use an absolute path rather than the relative path:

```dart
@EmbedStr("/pubspec.yaml")
const pubspec = _$pubspec;
```

If you specify the content file path as an absolute path like the above snippet, it is treated as relative to the project root directory. In this example, the absolute path `/pubspec.yam` wil be interpreted by the code generator as `/path/to/project/root/pubspec.yaml`. Either method can be used for all annotations, so chose an appropriate one depending on your project structure.

### Embed a text content as a string literal

Use `EmbedStr` to expand an arbitary file content in a source file as a string literal, as it is.

```dart
// main.dart
@EmbedStr("useful_text.txt")
const usefulText = _$usefulText;
```

By default, it embeds the text content as a [raw string](https://dart.dev/language/built-in-types#strings):

```dart
// main.g.dart
const _$usefulText = r'''
This is a useful text for you.
''';
```

If it doesn't work well with your text contet, disable this behavior by specifying `EmbedStr.raw` to `false`:

```dart
@EmbedStr("useful_text.txt", raw: false)
```

This will generates a general string literal:

```dart
const _$usefulText = '''
This is a useful text for you.
''';
```

<br/>

### Embed a structured data as a Dart object

Use `EmbedLiteral` to convert a structured data file such as JSON to an dart object and embed it in source file. This is useful when you want to read non-dart file that is bundled in your package in type safe manner,  without worring about runtime errors and async I/O operations. Currently, `EmbedLiteral` supports JSON, TOML and YAML files. 

```dart
// main.dart
@EmbedLiteral("config.json")
const config = _$config;
```

If the `config.json` is like:

```json
// This is just an example, don't care about the meaning of the content :)
{
  "url": "https://api.example.com",
  "api_key": "AJFKEl04i9jlsLJFXS9w09",
  "default": 2,
}
```

Then, the code generator will dump the following code:

```dart
// main.g.dart
const _$config = (
  url: "https://api.example.com",
  apiKey: "AJFKEl04i9jlsLJFXS9w09",
  $default: 2,
);
```

You can see the given JSON data is converted as a [record object](https://dart.dev/language/records). And if you take a close look at the output, you might notice that some JSON keys are also converted to camelCase. This is because it is the recommeded style for the field names of record type. 

One more thing, if a [reserved keyword](https://dart.dev/language/keywords) like `if` is used as a JSON key, the code generator automatically adds a `$` sign at the begining of the key; e.g. in the above example, a JSON key `default` is converted to `$default` in the dart code.

#### How is the data type determined?

The code generator attempts to represent map-like data as records rather than `Map`s whenever possible. For examle, the following JSON file will be converted as a record because the all keys have valid format as a record field name:

```JSON
{
  "snake_case": 0,
  "camelCase": "text",
  "PascalCase": true,
}
```

On the other hand, the next JSON will be converted as a `Map<String, Object>` bcause at least one of the keys have invalid format as a record field name:

```JSON
{
  "snake_case": 0, // This is fine
  "0_starts_with_number": "text", // BAD
  "contians *invalid* characters!": true, // BAD
}
```

In this case, the output code will be a `Map` literal:

```dart
// main.g.dart
const _$config = {
  "snake_case": 0,
  "0_starts_with_number": "text",
  "contians *invalid* characters!": true,
};
```

This rule is applied recursively if the input file contains nestd data structure, from root to leaf objects each time a map-like structure is converted to a literal representation.

#### How to restrict the structure of data to be embedded?

Currently, you can't LITERALLY restrict the types of generated dart objects. Whether a JSON data is embedded as a `Map` literal or a record literal depends on the content of the input file. However, it is easy to tell the dart compiler what shape of data you really want and have a static error occur if the generated code does not match those types.

```dart
// This is what you really want
typedef Config = ({ String url, String apiKey });

@EmbedLiteral("config.json")
const Config config = _$config; // Expects `_$config` to be of type `Config`
```

If the generated object `_$config` doesn't have the type of `Config`, the dart analyzer will raise a static error and tell you that the input file does not meet your requirements.

<br/>

## Troubleshooting Guide

### I edited my json file to embed, but the generated code does't be updated even if reruning build_runner

It seems that the `build_runner` cahces the previous output and if a source file doesn't changed compared to the previous one, it won't regenerate the code for the file. Since the source file doesn't changes before and after modifying the json file, the updates doesn't be reflected.

To avoid this problem, try to clear the cache before running the `build_runner` (replace `flutter` with `dart` if you are working in a Dart project) :

```shell
flutter pub run build_runner clean && flutter pub run build_runner build
```

If you are still having the problem using `flutter` command, you can also try this:

```shell
flutter clean && flutter pub run build_runner build
```

## Roadmap

- [ ] Restrict the type of dart object to be embedded by giving the corresponding variable a concrete type

## Contributing

Contributions are what make the open source community such an amazing place to learn, inspire, and create. Any contributions you make are **greatly appreciated**.

If you have a suggestion that would make this better, please fork the repo and create a pull request. You can also simply open an issue with the tag "enhancement".
Don't forget to give the project a star! Thanks again!

1. Fork the Project
2. Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3. Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the Branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

<br/>

## Thanks

* [Best-README-Template](https://github.com/othneildrew/Best-README-Template/tree/master) by [@othneildrew](https://github.com/othneildrew)
